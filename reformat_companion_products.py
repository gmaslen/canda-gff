from io import FileIO
import re
import sys
import argparse

def main():
    parser = argparse.ArgumentParser(description='Move Companion generated polypeptide product descriptions to CDS level objects in GFF file.')
    default_output = 'companion_reformatted_output.gff3'
    parser.add_argument('--gff', help='path of input GFF3 file', type=str, required=True )
    parser.add_argument('--out', help=f'path of output GFF3 file (optional, default={default_output})', type=str, required=False, default=default_output )

    args = parser.parse_args()
    
    input = args.gff
    output = args.out
            
    product_lookup, gene2cds = get_product_lkup( input )
    print( "\n" + str(len(product_lookup)) + " polypeptide product annotations to transfer" )
    merge_products( input, output, product_lookup, gene2cds)
    print("\nData written to file " + output)
    sys.exit(0)

def merge_products( fname:str, output:str, products:dict, gene2cds:dict ) -> None:
    """read input GFF3 file generated by Companion software and rewrite matching 
    parent:child entries for gene and CDS. Remap the product descriptions from the 
    polypeptide sequence feature type to all CDS level features for the parent gene.

    Args:
        fname (str): input GFF3 file
        output (str): output GFF3 file
        products (dict): dictionary lookup of products to gene ids
        gene2cds (dict): dictionary lookup of gene ids to CDS ids

    Returns:
        _type_: nothing
    """
#, 
# 

    out = open(output,'w')
    lcount = 0
    unmatchedCDS = 0
    matchedCDS = 0
    ignored = 0
    written = 0
       
    with open(fname)  as file:
        for l in file:
            lcount += 1
            basel = l.strip()
            elems = basel.split("\t")
            if len(elems) == 9:
                if elems[2] == 'CDS':
#map polypeptide product entries to CDS                    
#                    id = generateLocusIDstring(elems)
                    parent_gene = get_parent_id(elems[8])

                    if products.get(parent_gene):
                        existing= elems[8]
                        elems[8] = existing + ";product=" + products.get(parent_gene) 
                        out.write( "\t".join(elems) + "\n")
                        matchedCDS += 1
                        written += 1
                    else:
                        print("unable to find product match for CDS " + str(parent_gene) + " at line " + str(lcount))
                        unmatchedCDS += 1
                        out.write(basel + "\n")
                        written += 1
                elif elems[2] == 'polypeptide':
#ignore these lines as the prodcut= entry has been moved up to the CDS parent                    
                    ignored += 1
                    next  
                else:
                    out.write(basel + "\n")
                    written += 1
            else:
                    out.write(basel + "\n")
                    written += 1
    file.close() 
    print("Matched CDS entries = " + str(matchedCDS) + "\n")
    print("Unmatched CDS entries = " + str(unmatchedCDS) + "\n")
    print("processed lines = ", str(lcount))
    print("ignored lines   = ", str(ignored))
    print("written lines   = " , str(written))
    
def get_product_lkup( fname:str ):
    """generate dictionary of unique locus position based id to product description

    Args:
        fname (str): input GFF3 file

    Returns:
        dict : unique id + product description stings
    """
    id2product = {}
    gene2cds={} 
          
    with open(fname)  as file:
        for l in file:
            elems = l.strip().split("\t")
            if len(elems) == 9:
                if elems[2] == 'polypeptide':
                    product = get_product(elems[8])
                    parent_id = get_derived_id(elems[8])
                    if product :
#                        id = generateLocusIDstring(elems)                        
                        id2product.update({parent_id: product})
                    else:
                        print("no product for  " + l)
                elif elems[2] == 'CDS':
                    cds_id = get_id(elems[8])
                    gene_id = get_parent_id(elems[8])
                    gene2cds.update({ gene_id: cds_id })
    file.close()
    return id2product, gene2cds

def generateLocusIDstring( idparts:list) -> str:
    """generates unique string based on GFF3 sequence + start + stop + strand

    Args:
        idparts (list): GFF3 feature line

    Returns:
        str: concatenation of sequence + start + stop + strand GFF elements with : delimiter
    """
    
    loc = ( idparts[0], idparts[3], idparts[4], idparts[6])
    delim= ":"
    id = str(delim.join(loc))
    return id
                    
def get_product( attrib_str:str ) -> str:
    """extract product field from column 9 of GFF3 string

    Args:
        attrib_str (str): GFF3 column 9 string

    Returns:
        str : extracted product value from col 9 of GFF3 file
    """
    
    attribs= attrib_str.split(";")
    for a in attribs:
        keyval = a.split("=")
        if keyval[0] == "product":
#html encoding of elements present, split on %3B symbol for ; 
#remove term%3D for term= string as this contributes nothing to the product description
#translate %2C back to ASCII value=,           
            elements = keyval[1].split('%3B')
            base_p = elements[0].replace('term%3D' ,'')
            base_p2 = base_p.replace('%2C' ,',')
            return str(base_p2)

def get_parent_id( attrib_str:str ) -> str:
    """extract parent id from column 9 of GFF3 string

    Args:
        attrib_str (str): GFF3 column 9 string

    Returns:
        str : extracted parent_id value from col 9 of GFF3 file
    """
    
    attribs= attrib_str.split(";")
    for a in attribs:
        keyval = a.split("=")
        if keyval[0] == "Parent":
#html encoding of elements present, split on %3B symbol for ; 
#remove term%3D for term= string as this contributes nothing to the product description           
            elements = keyval[1].split('%3B')
            base_p = elements[0]
            return str(base_p)

def get_derived_id( attrib_str:str ) -> str:
    """extract derived id from column 9 of GFF3 string

    Args:
        attrib_str (str): GFF3 column 9 string

    Returns:
        str : extracted derived id value from col 9 of GFF3 file
    """
    
    attribs= attrib_str.split(";")
    for a in attribs:
        keyval = a.split("=")
        if keyval[0] == "Derives_from":
#html encoding of elements present, split on %3B symbol for ; 
#remove term%3D for term= string as this contributes nothing to the product description           
            elements = keyval[1].split('%3B')
            base_p = elements[0]
            return str(base_p)
        
def get_id( attrib_str:str ) -> str:
    """extract id from column 9 of GFF3 string

    Args:
        attrib_str (str): GFF3 column 9 string

    Returns:
        str : extracted id value from col 9 of GFF3 file
    """
    
    attribs= attrib_str.split(";")
    for a in attribs:
        keyval = a.split("=")
        if keyval[0] == "ID":
#html encoding of elements present, split on %3B symbol for ; 
#remove term%3D for term= string as this contributes nothing to the product description           
            elements = keyval[1].split('%3B')
            base_p = elements[0]
            return str(base_p)        
  
if __name__ == '__main__':
    main()
    sys.exit(0)